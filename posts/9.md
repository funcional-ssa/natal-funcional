---
title: "9 - Schönfinkelisação e Aplicação Parcial"
author: "Kjetil Valle"
translatedBy: "Andrei Macedo"
date: "09 de dezembro de 2020"
published: false
description: "Como discutimos em um artigo anterior, uma das coisas que podemos fazer com uma função é chamá-la com menos argumentos do que ela espera. Isso irá resultar em uma nova função onde os argumentos que nós providenciamos estão ligados a valores, e os argumentos restantes ainda são esperados como parâmetros. Como nós aplicamos a função para apenas alguns de seus argumentos, chamamos essa técnica de  aplicação parcial."
---

## Schönfinkelisação e Aplicação Parcial

Como discutimos em um artigo anterior, uma das coisas que podemos fazer com uma função é chamá-la com menos argumentos do que ela espera. Isso irá resultar em uma nova função onde os argumentos que nós providenciamos estão ligados a valores, e os argumentos restantes ainda são esperados como parâmetros. Como nós aplicamos a função para apenas alguns de seus argumentos, chamamos essa técnica de  aplicação parcial.

Vamos ver como isso funciona em Elm:

```elm
-- Uma função simples, que soma 2 argumentos.
-- Se você acha a assinatura de tipos confusa, não se preocupe
--- com isso agora.
add : number -> number -> number
add a b = 
	a + b

-- Uma função relativamente inútil, usada para ilustrar
-- aplicação parcial…
incrementByFive : number -> number
incrementByFife =
	-- Aqui nós aplicamos parcialmente a função `add`. Ao
	-- providenciar apenas o primeiro argumento, 
	-- nós temos uma nova função em retorno, que vai
	-- aceitar outro número, o qual sempre irá ser adicionado a 5.
	add 5

-- Sim, isso nos retornaria 42
incrementByFive 37
```

## Currying

O fato de que podemos chamar a função `add` com apenas um argumento pode te surpreender. Mas, de fato, é possível transformar uma função com qualquer número de argumentos em uma função com apenas um ao usar um processo chamado currying.

Digamos que temos essa pequena função em JavaScript:

```js
function add(a, b) {
	return a + b
}
```

Nós não podemos simplesmente aplicar parcialmente essa função. Em JavaScript você precisa providenciar todos os argumentos quando aplicar uma função. Contudo, nós podemos definir essa função no lugar:

```js
function curriedAdd(a) {
	return function(b) {
		return a + b
	}
}
```

Ao usar currying, nós podemos converter `add` em `curriedAdd`. E esse processo vai trabalhar com funções de qualquer número de argumentos. E com essa nova função, nós estamos livres para fazer coisas como essa novamente:

```js
incrementByFive = curriedAdd(5)
```

Mas por quê nós não precisamos fazer isso em Elm? Isso é porque em Elm, assim como muitas outras linguagens de programação funcional, o currying das funções é feito por padrão. Isso significa que todas as funções podem ser facilmente parcialmente aplicadas! E isso é também o motivo pelo qual a assinatura de tipos que vimos no primeiro exemplo se parece com isso: 

```elm
add : number -> number -> number
```

Uma maneira diferente de ler esse tipo seria assim:

```elm
add : number -> (number -> number)
```

Então, como pode ver, `add` é de fato uma função que toma apenas um argumento (um `number`) e retorna uma função (com o tipo `number -> number`).

## Por que isso é útil?

O exemplo `incrementByFive` acima é obviamente artificial. Mas você se surpreenderia com o quão frequentemente a aplicação parcial acaba sendo útil ao escrever código em uma linguagem funcional.

Isso ocorre frequentemente quando estamos usando funções como map ou filter. Essas funções esperam um argumento que é uma função que pode ser aplicada a todos os elementos de uma lista, e que deve então tomar exatamente um argumento. É conveniente criar essa função utilizando a aplicação parcial.

Aqui estão alguns exemplos, novamente usando Elm.

```elm
-- Converte uma lista de `Maybe String` em algo que
-- Pode ser mostrado ao usuário, usando "n/a" onde
-- não temos um valor.
displayNames = List.map (Maybe.withDefault "n/a") [ Just "NBN", Nothing, Just "Jinteki", Just "Wayland"]
-- Resultado: [ "NBN", "n/a", "Jinteki", "Wayland" ]

-- Filtra uma lista de nomes para incluir apenas as pessoas
-- chamadas "John"
johns = List.filter (String.startsWith "John") [ "John Snow", "John Rambo", "James Bond", "John McClane", "Jack Bauer"]
-- Resultado: [ "John Snow", "John Rambo", "John McClane" ]
```

Ambos [Maybe.withDefault](https://package.elm-lang.org/packages/elm/core/latest/Maybe#withDefault) e [String.startsWith](https://package.elm-lang.org/packages/elm/core/latest/String#startsWith) esperam receber 2 argumentos, mas apenas ao aplicá-los parcialmente nós recebemos o que precisamos.

Como outro exemplo, digamos que nós temos uma função com a seguinte assinatura de tipo em nossa aplicação Elm.

```elm
log : LogConfig -> Message -> Cmd msg
```

A função pecisa de um tipo de configuração e uma mensagem. A depender da configuração, a mensagem pode ser usada como log em um serviço de backend ou talvez ao console de um browser. Especificar a configuraçao em todos os lugares em que precisamos de um log seria incômodo. No lugar disso nós podemos apenas aplicar parcialmente o log para a configuração uma vez, e usar a função resultante no resto da aplicação!

Quanto mais acostumado você fica com programação funcional, mais lugares você irá encontrar onde uma função parcialmente aplicada é exatamente o que você precisa.

## Schönfinkeli-o-quê?

O nome currying é uma referência ao matemático Americano Haskell Brooks Curry. (Se o nome parece familiar, não é coincidência: O Sr. Curry é bastante popular entre os cientistas da computação, e tem de fato três linguagens nomeadas em homenagem a ele: [Haskell](https://www.haskell.org/), [Brook](http://graphics.stanford.edu/projects/brookgpu/) e [Curry](https://www-ps.informatik.uni-kiel.de/currywiki/)…)

No entando, ele não foi o responsável por descobrir a técnica de currying. O matemático Russo Moses Ilyich Schönfinkel já havia descrito o conceito previamente, e foi também atribuído por Curry por isso. Então, talvez nós devêssemos começar a referenciar isso como *schönfinkelisation*?
